<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ëª¨ë¸ ë·°ì–´ - ë¶€íŠ¸ìŠ¤íŠ¸ë© í†µí•© ë²„ì „</title>
    
    <!-- ë¶€íŠ¸ìŠ¤íŠ¸ë© CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Three.js ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

    <style>
        #viewer {
            width: 100%;
            height: 70vh;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .toast-container {
            z-index: 9999;
        }
    </style>
</head>

<body class="bg-light">
    <!-- ë„¤ë¹„ê²Œì´ì…˜ ë°” -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="#">3D Viewer Pro</a>
            <div class="d-flex gap-2">
                <label class="btn btn-outline-light">
                    ğŸ“¦ ëª¨ë¸ ì—…ë¡œë“œ
                    <input type="file" id="modelInput" hidden accept=".obj">
                </label>
                <label class="btn btn-outline-light">
                    ğŸ¨ í…ìŠ¤ì²˜ ì¶”ê°€
                    <input type="file" id="textureInput" hidden accept=".jpg,.png,.jpeg">
                </label>
            </div>
        </div>
    </nav>

    <!-- ë©”ì¸ ì½˜í…ì¸  -->
    <div class="container-fluid mt-4">
        <div class="row g-4">
            <!-- 3D ë·°ì–´ ì˜ì—­ -->
            <div class="col-lg-9">
                <div class="card shadow-sm">
                    <div class="card-body p-0">
                        <div id="viewer"></div>
                    </div>
                </div>
            </div>

            <!-- ì •ë³´ íŒ¨ë„ -->
            <div class="col-lg-3">
                <div class="card shadow-sm h-100">
                    <div class="card-header bg-primary text-white">
                        ëª¨ë¸ ì •ë³´
                    </div>
                    <div class="card-body">
                        <dl class="row mb-0" id="file-info">
                            <dt class="col-sm-5">íŒŒì¼ í˜•ì‹:</dt>
                            <dd class="col-sm-7" id="file-type">-</dd>
                            
                            <dt class="col-sm-5">í…ìŠ¤ì²˜ ìƒíƒœ:</dt>
                            <dd class="col-sm-7" id="texture-status">ë¯¸ì ìš©</dd>
                        </dl>
                    </div>
                </div>
            </div>
            <div class="card shadow-sm mt-3">
                <div class="card-header bg-success text-white">
                    í…ìŠ¤ì²˜ ì¡°ì ˆ
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">ì±„ë„ (Saturation)</label>
                        <input type="range" class="form-range" id="saturationSlider" min="0" max="2" step="0.1" value="1">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">ë°ê¸° (Brightness)</label>
                        <input type="range" class="form-range" id="brightnessSlider" min="0" max="2" step="0.1" value="1">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- í† ìŠ¤íŠ¸ ì•Œë¦¼ ì»¨í…Œì´ë„ˆ -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3"></div>

    <!-- ë¶€íŠ¸ìŠ¤íŠ¸ë© JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Three.js êµ¬í˜„ ì½”ë“œ -->
    <script>
        let scene, camera, renderer, controls, currentModel = null;

        // ì´ˆê¸°í™” í•¨ìˆ˜
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 500, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            
            const viewer = document.getElementById('viewer');
            renderer.setSize(viewer.offsetWidth, viewer.offsetHeight);
            viewer.appendChild(renderer.domElement);

            // ì¡°ëª… ì„¤ì •
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 10, 0);
            scene.add(directionalLight);

            // ì¹´ë©”ë¼ ìœ„ì¹˜
            camera.position.set(0, 2, 5);

            // OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const axesHelper = new THREE.AxesHelper(10); // ê¸¸ì´ 10ì˜ XYZ ì¶• í‘œì‹œ
            scene.add(axesHelper);

            scene.background = new THREE.Color(0xE2E2E2); // í•˜ëŠ˜ìƒ‰
        }

        const textureShader = {
            uniforms: {
                tDiffuse: { value: null },
                uHue: { value: 0 },
                uSaturation: { value: 1 },
                uBrightness: { value: 1 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float uHue;
                uniform float uSaturation;
                uniform float uBrightness;
                varying vec2 vUv;

                vec3 rgb2hsv(vec3 c) {
                    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
                    float d = q.x - min(q.w, q.y);
                    float e = 1.0e-10;
                    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
                }

                vec3 hsv2rgb(vec3 c) {
                    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                }

                void main() {
                    vec4 texColor = texture2D(tDiffuse, vUv);
                    vec3 hsv = rgb2hsv(texColor.rgb);
                    
                    hsv.x += uHue / 360.0;
                    hsv.y *= uSaturation;
                    hsv.z *= uBrightness;
                    
                    gl_FragColor = vec4(hsv2rgb(hsv), texColor.a);
                }
            `
        };

        // íŒŒì¼ ì²˜ë¦¬ ì‹œìŠ¤í…œ
        const handleFileUpload = (type, file) => {
            if (!validateFile(file, type)) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                if(type === 'model') processModel(e.target.result, file.name);
                else applyTexture(e.target.result);
            };
            reader.onerror = (error) => showToast(`íŒŒì¼ ì˜¤ë¥˜: ${error}`, 'danger');
            
            type === 'model' ? reader.readAsText(file) : reader.readAsDataURL(file);
        };

        // ëª¨ë¸ ì²˜ë¦¬
        function processModel(content, filename) {
            try {
                if(currentModel) scene.remove(currentModel);
                
                currentModel = new THREE.OBJLoader().parse(content);
                scene.add(currentModel);
                updateFileInfo('file-type', `OBJ (${filename})`);
                showToast('ëª¨ë¸ ë¡œë“œ ì™„ë£Œ!', 'success');
            } catch (error) {
                showToast('ëª¨ë¸ íŒŒì‹± ì‹¤íŒ¨', 'danger');
            }
        }

        // í…ìŠ¤ì²˜ ì ìš© í•¨ìˆ˜ ìˆ˜ì •
        function applyTexture(textureURL) {
            new THREE.TextureLoader().load(textureURL, texture => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;

                currentModel.traverse(child => {
                    if (child.isMesh) {
                        child.material = new THREE.ShaderMaterial({
                            ...textureShader,
                            uniforms: {
                                tDiffuse: { value: texture },
                                uHue: { value: 0 },
                                uSaturation: { value: 1 },
                                uBrightness: { value: 1 }
                            }
                        });
                    }
                });
                updateFileInfo('texture-status', 'ì ìš© ì™„ë£Œ');
                showToast('í…ìŠ¤ì²˜ ì ìš© ì„±ê³µ!', 'success');
            });
        }

        // ìƒ‰ìƒ ì¡°ì ˆ ì—…ë°ì´íŠ¸
        function updateTextureParams() {
            currentModel.traverse(child => {
                if (child.isMesh && child.material.uniforms) {
                    child.material.uniforms.uSaturation.value = parseFloat(saturationSlider.value);
                    child.material.uniforms.uBrightness.value = parseFloat(brightnessSlider.value);
                }
            });
        }

        // ëª¨ë¸ ë³€í˜• ì‹œìŠ¤í…œ ì¬êµ¬í˜„
        let isDragging = false;
        let startPos = new THREE.Vector2();
        let initialScale = new THREE.Vector3();
        let initialPosition = new THREE.Vector3();

        function onMouseDown(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentModel, true);
            
            if(intersects.length > 0) {
                isDragging = true;
                startPos.set(event.clientX, event.clientY);
                initialPosition.copy(currentModel.position);
                initialScale.copy(currentModel.scale);
                controls.enabled = false;
            }
        }

        function onMouseMove(event) {
            if(!isDragging || !currentModel) return;
            
            const deltaX = event.clientX - startPos.x;
            const deltaY = event.clientY - startPos.y;

            // ì´ë™ ì¡°ì‘ (ì›”ë“œ ì¢Œí‘œê³„ ê¸°ì¤€)
            currentModel.position.x = initialPosition.x + deltaX * 0.01;
            currentModel.position.y = initialPosition.y - deltaY * 0.01;

            // Shift + ìˆ˜ì§ ë“œë˜ê·¸: í¬ê¸° ì¡°ì ˆ
            if(event.shiftKey) {
                const scaleFactor = 1 + deltaY * 0.005;
                currentModel.scale.set(
                    initialScale.x * scaleFactor,
                    initialScale.y * scaleFactor,
                    initialScale.z * scaleFactor
                );
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²°
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', () => {
            isDragging = false;
            controls.enabled = true;
        });

        // ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸ ì—°ê²°
        document.getElementById('saturationSlider').addEventListener('input', updateTextureParams);
        document.getElementById('brightnessSlider').addEventListener('input', updateTextureParams);

        // ìœ íš¨ì„± ê²€ì‚¬
        function validateFile(file, type) {
            const validTypes = {
                model: ['obj'],
                texture: ['jpg', 'jpeg', 'png']
            };
            const ext = file.name.split('.').pop().toLowerCase();
            
            if (!validTypes[type].includes(ext)) {
                showToast(`ì˜ëª»ëœ íŒŒì¼ í˜•ì‹: .${ext}`, 'danger');
                return false;
            }
            return true;
        }

        // UI ì—…ë°ì´íŠ¸
        function updateFileInfo(targetId, value) {
            const element = document.getElementById(targetId);
            element.textContent = value;
            element.classList.add('text-success');
            setTimeout(() => element.classList.remove('text-success'), 1000);
        }

        // í† ìŠ¤íŠ¸ ì•Œë¦¼
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast align-items-center text-bg-${type}`;
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>`;
            
            document.querySelector('.toast-container').appendChild(toast);
            new bootstrap.Toast(toast, {autohide: true}).show();
        }

        // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ëŸ¬
        window.addEventListener('resize', () => {
            const viewer = document.getElementById('viewer');
            camera.aspect = viewer.offsetWidth / viewer.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewer.offsetWidth, viewer.offsetHeight);
        });

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('modelInput').addEventListener('change', e => 
            handleFileUpload('model', e.target.files[0]));
        document.getElementById('textureInput').addEventListener('change', e => 
            handleFileUpload('texture', e.target.files[0]));

        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // ì´ˆê¸°í™” ì‹¤í–‰
        initThreeJS();
        animate();
    </script>
</body>
</html>